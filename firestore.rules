rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // ====== Helper Functions ======
    // ====== Moderation Functions ======
    function isModerator() {
      return isSignedIn() && 
             request.auth.token.roles != null && 
             request.auth.token.roles.moderator == true;
    }
    
    function isAdmin() {
      return isSignedIn() && 
             request.auth.token.roles != null && 
             request.auth.token.roles.admin == true;
    }
    
    function canModerateContent() {
      return isModerator() || isAdmin();
    }
    
    function isValidModerationAction() {
      let validStatuses = ['approved', 'rejected', 'pending', 'flagged'];
      return request.resource.data.moderationStatus in validStatuses;
    }
    
    function hasValidModerationFields() {
      return request.resource.data.keys().hasAll(['moderationStatus', 'moderatedAt', 'moderatedBy']);
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }
    
    function isEmailVerified() {
      return isSignedIn() && request.auth.token.email_verified == true;
    }
    
    function hasAppCheck() {
      return request.auth.token.firebase != null && 
             request.auth.token.firebase.app_check != null;
    }

    function isValidString(value, minLength, maxLength) {
      return value is string &&
             value.size() >= minLength &&
             value.size() <= maxLength &&
             !value.matches('.*<script.*>.*</script>.*') && // No script tags
             !value.matches('.*javascript:.*'); // No javascript URLs
    }
    
    function isRateLimited(action) {
      let lastAction = get(/databases/$(database)/documents/rateLimits/$(request.auth.uid)/actions/$(action));
      return !exists(lastAction.data) || 
             request.time > lastAction.data.timestamp + duration.value(1, 'm');
    }
    
    function hasNoSQLInjection(value) {
      return !value.matches('.*[\\$\\{\\}\\[\\]].*'); // Block common injection patterns
    }
    
    function hasProfanity(text) {
      // List of inappropriate words to block (simplified for production)
      // In production, consider using Firebase Extensions for content moderation
      return text.matches('(?i).*(hate|violence|harassment|spam).*');
    }
    
    function isValidTimestamp(field) {
      return request.resource.data[field] == request.time;
    }
    
    function isValidReview() {
      return isSignedIn() &&
        isEmailVerified() && // Require email verification
        request.resource.data.keys().hasAll(['title', 'content', 'authorId', 'createdAt', 'category', 'rating']) &&
        request.resource.data.authorId == request.auth.uid &&
        isValidString(request.resource.data.title, 1, 200) &&
        hasNoSQLInjection(request.resource.data.title) &&
        !hasProfanity(request.resource.data.title) && // Check for profanity in title
        isValidString(request.resource.data.content, 10, 5000) &&
        hasNoSQLInjection(request.resource.data.content) &&
        !hasProfanity(request.resource.data.content) && // Check for profanity in content
        isValidString(request.resource.data.category, 1, 50) &&
        request.resource.data.rating is number &&
        request.resource.data.rating >= 1 &&
        request.resource.data.rating <= 5 &&
        isValidTimestamp('createdAt') &&
        isRateLimited('createReview'); // Rate limit review creation
    }



    // ====== User Profiles ======
    match /users/{userId} {
      // Anyone authenticated can read basic profile info
      allow read: if isSignedIn();

      // Users can only create their own profile
      allow create: if isOwner(userId) &&
        request.resource.data.keys().hasAll(['email', 'createdAt']) &&
        (request.resource.data.get('email', '') == '' ||
         request.resource.data.email == request.auth.token.email);

      // Users can only update their own profile
      allow update: if isOwner(userId);

      // Soft delete only through cloud functions
      allow delete: if false;
    }
    
    // ====== User Private Data ======
    match /users/{userId}/private/{document=**} {
      allow read, write: if isOwner(userId);
    }
    
    // ====== Reviews (Dating Reviews) ======
    // ====== Moderated Reviews ======
    match /reviews/{reviewId} {
      // Public can read all reviews (temporarily relaxed for debugging)
      allow read: if true;

      // Authenticated users can create reviews (simplified validation)
      allow create: if isSignedIn() &&
        request.resource.data.keys().hasAll(['authorId', 'content', 'rating', 'createdAt']) &&
        request.resource.data.authorId == request.auth.uid &&
        isValidString(request.resource.data.content, 10, 5000) &&
        request.resource.data.rating is number &&
        request.resource.data.rating >= 1 &&
        request.resource.data.rating <= 5;

      // Authors can update their own reviews, allow view count updates
      allow update: if isSignedIn() &&
        ((resource.data.authorId == request.auth.uid &&
          request.resource.data.authorId == resource.data.authorId) ||
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['views', 'likes', 'dislikes'])));

      // Authors can delete their own reviews, moderators can delete any
      allow delete: if isSignedIn() &&
        (resource.data.authorId == request.auth.uid || canModerateContent());
    }
    
    // ====== Review Comments ======
    match /reviews/{reviewId}/comments/{commentId} {
      allow read: if true;
      
      allow create: if isSignedIn() &&
        isEmailVerified() &&
        request.resource.data.authorId == request.auth.uid &&
        isValidString(request.resource.data.content, 1, 1000) &&
        hasNoSQLInjection(request.resource.data.content) &&
        request.resource.data.keys().hasAll(['content', 'authorId', 'createdAt']) &&
        isValidTimestamp('createdAt') &&
        isRateLimited('createComment');
      
      allow update: if isSignedIn() && 
        resource.data.authorId == request.auth.uid &&
        request.resource.data.authorId == resource.data.authorId;
      
      allow delete: if isSignedIn() && 
        resource.data.authorId == request.auth.uid;
    }
    
    // ====== Chat Rooms ======
    match /chatRooms/{roomId} {
      // Allow authenticated users to list/query chatRooms and read specific rooms
      // The app queries with where('participants', 'array-contains', userId)
      allow read: if isSignedIn();
      
      // Create room with creator as member or participant
      allow create: if isSignedIn() &&
        (request.auth.uid in request.resource.data.get('members', []) ||
         request.auth.uid in request.resource.data.get('participants', [])) &&
        isValidString(request.resource.data.get('name', ''), 1, 100);
      
      // Members or participants can update room info, OR users can join by adding themselves to participants
      allow update: if isSignedIn() &&
        (request.auth.uid in resource.data.get('members', []) ||
         request.auth.uid in resource.data.get('participants', []) ||
         // Allow joining: user is adding themselves to participants array
         (request.auth.uid in request.resource.data.get('participants', []) &&
          !(request.auth.uid in resource.data.get('participants', []))));
      
      // Archive instead of delete
      allow delete: if false;
    }
    
    // ====== Chat Messages ======
    match /chatRooms/{roomId}/messages/{messageId} {
      // Room members or participants can read messages
      allow read: if isSignedIn() &&
        (request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(roomId)).data.get('members', []) ||
         request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(roomId)).data.get('participants', []));
      
      // Room members or participants can send messages with rate limiting
      allow create: if isSignedIn() &&
        isEmailVerified() &&
        (request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(roomId)).data.get('members', []) ||
         request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(roomId)).data.get('participants', [])) &&
        request.resource.data.senderId == request.auth.uid &&
        isValidString(request.resource.data.content, 1, 2000) &&
        hasNoSQLInjection(request.resource.data.content) &&
        request.resource.data.keys().hasAll(['content', 'senderId', 'createdAt']) &&
        isValidTimestamp('createdAt') &&
        isRateLimited('sendMessage');
      
      // Senders can edit their own messages
      allow update: if isSignedIn() && 
        resource.data.senderId == request.auth.uid &&
        request.resource.data.senderId == resource.data.senderId;
      
      // Soft delete only
      allow delete: if false;
    }
    
    // ====== Notifications ======
    match /notifications/{notificationId} {
      // Allow authenticated users to read all notifications (will be filtered client-side)
      allow read: if isSignedIn();
      
      // Allow authenticated users to create notifications
      allow create: if isSignedIn();
      
      // Users can update notifications
      allow update: if isSignedIn();
      
      // Users can delete notifications
      allow delete: if isSignedIn();
    }
    
    // Legacy nested notifications path
    match /notifications/{userId}/items/{notificationId} {
      // Users can read their own notifications
      allow read: if isOwner(userId);
      
      // Users can create their own notifications (for testing)
      allow create: if isOwner(userId);
      
      // Users can mark notifications as read
      allow update: if isOwner(userId) && 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt']);
      
      // Users can delete their own notifications
      allow delete: if isOwner(userId);
    }
    
    // ====== Content Reports ======
    match /reports/{reportId} {
      // Only admins can read reports (via Cloud Functions)
      allow read: if false;
      
      // Authenticated, verified users can report content with rate limiting
      allow create: if isSignedIn() &&
        isEmailVerified() &&
        request.resource.data.reporterId == request.auth.uid &&
        request.resource.data.keys().hasAll(['type', 'targetId', 'reason', 'createdAt']) &&
        isValidString(request.resource.data.type, 1, 20) &&
        isValidString(request.resource.data.targetId, 1, 100) &&
        isValidString(request.resource.data.reason, 10, 500) &&
        hasNoSQLInjection(request.resource.data.reason) &&
        isValidTimestamp('createdAt') &&
        isRateLimited('createReport');
      
      // No updates or deletes allowed
      allow update, delete: if false;
    }
    
    // ====== User Settings ======
    match /userSettings/{userId} {
      allow read, write: if isOwner(userId);
    }
    
    // ====== Public Data ======
    match /public/{document=**} {
      // Anyone can read public data
      allow read: if true;
      // Only admin via Cloud Functions can write
      allow write: if false;
    }
    
    // ====== Rate Limiting ======
    match /rateLimits/{userId}/actions/{action} {
      // Users can read their own rate limit data
      allow read: if isOwner(userId);
      
      // System functions can write rate limit data
      allow write: if false; // Managed by Cloud Functions
    }
    
    // ====== User Reputation ======
    match /users/{userId}/reputation/{reputationId} {
      // Users can read their own reputation
      allow read: if isOwner(userId);
      
      // Only system or moderators can create/update reputation
      allow create, update: if false; // Managed by Cloud Functions
      
      // No direct deletion
      allow delete: if false;
    }

    // ====== Deny All Other Access ======
    match /{document=**} {
      allow read, write: if false;
    }
  }
}