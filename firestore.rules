rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions for enhanced security
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isValidString(value, minLength, maxLength) {
      return value is string &&
             value.size() >= minLength &&
             value.size() <= maxLength;
    }

    function isValidEmail(email) {
      return email is string &&
             email.matches('.*@.*\\..*') &&
             email.size() <= 254;
    }

    function isRateLimited(userId, action) {
      // Simplified rate limiting - allow all requests for now
      // In production, you might want to implement proper rate limiting
      return true;
    }

    // Users collection - enhanced security for anonymous users
    match /users/{userId} {
      // Allow users to read their own data
      allow read: if isOwner(userId);

      // Allow users to read basic anonymous profile info of other users
      allow read: if isAuthenticated() &&
        resource != null &&
        resource.data.keys().hasAny(['name', 'reputationScore', 'verified', 'isAnonymous']);

      // Validate user data on create - more permissive for initial creation
      allow create: if isOwner(userId) &&
        isRateLimited(request.auth.uid, 'createUser') &&
        request.resource.data.keys().hasAny(['email', 'name']) &&
        (request.resource.data.get('email', '') == '' || isValidEmail(request.resource.data.email)) &&
        (request.resource.data.get('name', '') == '' || isValidString(request.resource.data.name, 1, 50));

      // Allow updates with validation - more flexible for profile completion
      allow update: if isOwner(userId) &&
        isRateLimited(request.auth.uid, 'updateUser') &&
        // Allow email to be set if it was empty, but not changed if already set
        ((!('email' in resource.data) || resource.data.email == '') ||
         request.resource.data.get('email', resource.data.email) == resource.data.email) &&
        // Validate username if changed
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['name']) ||
         isValidString(request.resource.data.name, 1, 50));
    }

    // Reviews collection - enhanced validation for anonymous reviews
    match /reviews/{reviewId} {
      allow read: if isAuthenticated();

      allow create: if isAuthenticated() &&
        request.auth.uid == request.resource.data.authorId &&
        isValidString(request.resource.data.content, 10, 5000) &&
        isValidString(request.resource.data.targetName, 1, 100) &&
        isValidString(request.resource.data.category, 1, 50) &&
        request.resource.data.isAnonymous == true &&
        request.resource.data.rating is number &&
        request.resource.data.rating >= 1 &&
        request.resource.data.rating <= 5 &&
        isRateLimited(request.auth.uid, 'createReview');

      allow update: if isAuthenticated() &&
        request.auth.uid == resource.data.authorId &&
        // Only allow updating content, not metadata
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['content', 'updatedAt']) &&
        isValidString(request.resource.data.content, 10, 5000);

      allow delete: if isAuthenticated() &&
        request.auth.uid == resource.data.authorId;
    }

    // Comments collection - for review comments
    match /comments/{commentId} {
      allow read: if isAuthenticated();

      allow create: if isAuthenticated() &&
        request.auth.uid == request.resource.data.authorId &&
        isValidString(request.resource.data.content, 1, 1000) &&
        request.resource.data.isAnonymous == true &&
        isRateLimited(request.auth.uid, 'createComment');

      allow update, delete: if isAuthenticated() &&
        request.auth.uid == resource.data.authorId;
    }

    // Chat rooms collection - enhanced for anonymous users
    match /chatRooms/{roomId} {
      allow read: if isAuthenticated() &&
        (request.auth.uid in resource.data.participants ||
         resource.data.isPublic == true);

      // Allow system to create initial chat rooms
      allow create: if (isAuthenticated() &&
        request.auth.uid == request.resource.data.createdBy &&
        isValidString(request.resource.data.name, 1, 100) &&
        request.resource.data.isAnonymous == true &&
        request.resource.data.participants.size() <= 100) ||
        (request.resource.data.createdBy == 'system' &&
         isValidString(request.resource.data.name, 1, 100));

      allow update: if isAuthenticated() &&
        (request.auth.uid == resource.data.createdBy ||
         request.auth.uid in resource.data.moderators);
    }

    // Messages subcollection - enhanced validation
    match /chatRooms/{roomId}/messages/{messageId} {
      allow read: if isAuthenticated() &&
        (request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(roomId)).data.participants ||
         get(/databases/$(database)/documents/chatRooms/$(roomId)).data.isPublic == true);

      allow create: if isAuthenticated() &&
        request.auth.uid == request.resource.data.senderId &&
        isValidString(request.resource.data.content, 1, 2000) &&
        request.resource.data.isAnonymous == true &&
        isRateLimited(request.auth.uid, 'createMessage');

      allow update, delete: if isAuthenticated() &&
        request.auth.uid == resource.data.senderId;
    }

    // Notifications collection - users can only access their own
    match /notifications/{notificationId} {
      allow read, write: if isAuthenticated() &&
        request.auth.uid == resource.data.userId;

      allow create: if isAuthenticated() &&
        isValidString(request.resource.data.title, 1, 100) &&
        isValidString(request.resource.data.message, 1, 500);
    }

    // Reports collection - for content moderation
    match /reports/{reportId} {
      allow create: if isAuthenticated() &&
        request.auth.uid == request.resource.data.reporterId &&
        isValidString(request.resource.data.reason, 1, 500) &&
        isValidString(request.resource.data.contentType, 1, 50) &&
        isRateLimited(request.auth.uid, 'createReport');

      // Only admins can read reports (implement admin check in Functions)
      allow read: if false;
    }

    // User settings collection - for anonymous user preferences
    match /userSettings/{userId} {
      allow read, write: if isOwner(userId);

      allow create, update: if isOwner(userId) &&
        request.resource.data.keys().hasOnly([
          'privacy', 'notifications', 'anonymousPreferences', 'locationSettings'
        ]);
    }

    // It is also necessary to add rules for the new 'rateLimits' collection
    match /rateLimits/{userId}/actions/{action} {
      // Allow user to create/update their own rate limit timestamps
      allow write: if request.auth.uid == userId;
    }

    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}